#!/bin/bash

file="$1"

if [ $# -lt 1 ] || ! [ -f "$file" ]; then
	echo "Usage: $0 <input_file> [<start_at>] [<additional_ffmpeg_args>]"
	echo -e "\tReencodes <input_file> to reduce filesize, copying all tracks"
	echo -e "\tMay not accept unix or windows style paths (not implemented)"
	echo -e "\tOptionally cut everything before the timestamp <start_at> (hh:mm:ss.xxx)."
	echo -e "\t\tTo pass additional args without cutting, pass an invalid format, e.g. empty string"
	exit
fi


start_timestamp=""
if [[ $2 =~ ^[0-9]+(:[0-9]{2}){2}[.][0-9]{3}$ ]]; then
	start_timestamp="-ss $2"
	shift
fi

shift

bak="${file%.*}.bak.${file##*.}"
temp="${file%.*}.temp.mkv"

if [ -f "$bak" ] || [ -f "$temp" ]; then
	echo ".bak or .temp file already exists ... exiting"
	exit
fi

ffmpeg $start_timestamp -i "$file" $@ -c:v libx265 -crf 19 -preset slow -map 0 "$temp"

if ! [ -f "$temp" ]; then
	echo "Reencode failed ... exiting"
	exit
fi

out="${file%.*}.mkv"

mv -n "$file" "$bak"
mv -n "$temp" "$out"

size_diff=$(($(du "$bak" | awk '{print $1}')-$(du "$out" | awk '{print $1}')))
echo -e "
Finished converting
\t$(basename "$(cygpath "$file")")
Size reduced by
\t$size_diff k"
read -p "Open directory (y)? " ans
if [[ "$ans" == "y" ]]; then
	cygstart "$(dirname "$(cygpath "$out")")"
fi
